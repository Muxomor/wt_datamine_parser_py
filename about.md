# Техническое задание: Парсер shop.blkx для War Thunder с модулем локализации

## Описание проекта

Модульное Python-приложение для парсинга данных shop.blkx из игры War Thunder и преобразования их в структурированный CSV-файл с поддержкой локализации. Приложение обрабатывает древовидную структуру техники различных стран, типов и рангов, правильно определяет зависимости между техникой и разделяет обычную и премиумную технику, а также создает файл локализации с русскими названиями юнитов. Включает предварительную очистку от аномальных элементов для обеспечения стабильной работы.

## Архитектура проекта

### Структура файлов
```
project/
├── utils.py              # Конфигурация, логирование и константы (переименован из config.py)
├── shop_parser.py        # Основная логика парсинга shop.blkx
├── localization_parser.py # Парсинг локализации юнитов
├── main.py              # Точка входа и CLI интерфейс
├── config.txt           # Конфигурационный файл
└── README.md            # Документация
```

### Модули приложения

#### 1. **utils.py** - Инфраструктура и настройки
**Классы:**
- **Config** - чтение и управление конфигурацией из файла
- **Logger** - настройка логирования в файл и консоль
- **Constants** - все константы приложения (пороги, маппинги, поля)

**Основные константы:**
- `PREMIUM_THRESHOLD = 0.3` - порог определения премиум колонки (30%)
- `PROCESS_SLAVE_UNITS = False` - обрабатывать ли slave-юниты
- `VEHICLE_TYPE_MAPPING` - маппинг типов техники
- `COUNTRY_MAPPING` - маппинг стран
- `PREMIUM_INDICATORS` - признаки премиумной техники
- `ANOMALOUS_SUFFIXES` - список аномальных окончаний для удаления
- `LOCALIZATION_CSV_FIELDNAMES` - поля для CSV локализации

#### 2. **shop_parser.py** - Основная бизнес-логика
**Класс ShopParser:**
- Предварительная очистка от аномальных элементов
- Загрузка данных из удаленного источника shop.blkx
- Парсинг иерархической структуры техники
- Обработка master-slave пар и групп
- Определение зависимостей и координат
- Экспорт результатов в CSV

**Ключевые методы:**
- `fetch_shop_data()` - загрузка данных shop.blkx
- `has_anomalous_suffix()` - проверка на аномальные окончания
- `clean_anomalous_elements()` - предварительная очистка данных
- `collect_master_slave_pairs()` - предварительный сбор пар
- `parse_shop_data()` - основной парсинг с очисткой
- `process_country_data()` - обработка данных страны
- `save_to_csv()` - экспорт в CSV

#### 3. **localization_parser.py** - Парсинг локализации
**Класс LocalizationParser:**
- Загрузка данных локализации из удаленного источника CSV
- Парсинг CSV файла локализации с приоритетной системой
- Сопоставление ID юнитов с русскими названиями
- Обработка различных типов записей (shop, группы, числовые суффиксы)
- Экспорт маппинга локализации в CSV

**Ключевые методы:**
- `fetch_localization_data()` - загрузка CSV локализации
- `parse_localization_csv()` - парсинг с приоритетами
- `load_shop_ids()` - загрузка ID из shop.csv
- `create_localization_mapping()` - создание маппинга ID → название
- `_find_localization_for_id()` - умный поиск локализации
- `save_to_csv()` - экспорт локализации

#### 4. **main.py** - Точка входа и CLI
**Функции:**
- `main()` - полный парсинг (shop + локализация)
- `main_shop_only()` - только парсинг shop.blkx
- `main_localization_only()` - только парсинг локализации
- `print_help()` - справочная информация
- Обработка аргументов командной строки
- Проверка существования конфигурации
- Обработка ошибок и прерываний

## Основные возможности

### Парсер shop.blkx
- **Предварительная очистка** от аномальных элементов с проблемными окончаниями
- **Загрузка данных** из удаленного источника shop.blkx в формате JSON
- **Парсинг иерархической структуры** техники по странам и типам
- **Автоматическое определение** премиумных и обычных веток техники
- **Обработка master-slave пар** (техника с зависимыми юнитами)
- **Правильное определение зависимостей** между техникой (предшественники)
- **Обработка групп техники** с правильным наследованием координат
- **Экспорт в CSV** с полной информацией о технике

### Парсер локализации
- **Загрузка локализации** из удаленного CSV файла
- **Приоритетная система** обработки различных типов записей
- **Умный поиск** локализации с несколькими стратегиями
- **Обработка групп** и специальных случаев
- **Fallback механизм** для отсутствующих локализаций
- **Создание маппинга** ID → русское название

## Структура входных данных

### Формат shop.blkx
```json
{
  "country_germany": {
    "army": {
      "range": [
        {
          "техника_id": {
            "rank": 1,
            "reqAir": "",
            "gift": true,
            "showOnlyWhenBought": true
          },
          "группа_id_group": {
            "image": "#ui/unitskin#группа_id_group",
            "элемент1": { "rank": 1 },
            "элемент2": { "rank": 1 }
          }
        }
      ]
    }
  }
}
```

### Формат файла локализации (CSV)
```csv
"<ID|readonly|noverify>";"<English>";"<French>";"<Italian>";"<German>";"<Spanish>";"<Russian>";"<Polish>"...
"us_m41_walker_bulldog_shop";"M41A1";"M41A1";"M41A1 Walker Bulldog";"M41A1";"M41A1";"M41A1";"M41A1"...
"shop/group/he_112_group";"He 112";"He 112";"He 112";"He 112";"He 112";"He 112";"He 112"...
"cn_t_62_0";"Т-62 №545";"Т-62 №545";"Т-62 N°545";"Т-62 №545";"Т-62 N°545";"Т-62 №545";"Т-62 nr 545"...
```

## Алгоритм работы

### 1. Инициализация (main.py)
- Обработка аргументов командной строки
- Проверка существования конфигурационного файла
- Выбор режима работы (полный/только shop/только локализация)
- Создание экземпляров парсеров
- Обработка ошибок и прерываний

### 2. Настройка компонентов (utils.py)
- Чтение конфигурационного файла через класс `Config`
- Настройка логирования через класс `Logger`
- Загрузка констант из класса `Constants`

### 3. Предварительная очистка данных (shop_parser.py)

#### Система очистки от аномальных элементов
**Выполняется ПЕРЕД началом парсинга:**

**Аномальные окончания** (из `Constants.ANOMALOUS_SUFFIXES`):
- `_race` - гоночные события
- `_football` - футбольные события  
- `_yt_cup_2019` - YouTube Cup события
- `_event` - различные события

**Логика удаления "с корнем":**
- **Обычный элемент** с аномальным окончанием → удаляется
- **Группа содержит** аномальные элементы → удаляется вся группа
- **Сама группа** имеет аномальное окончание → удаляется со всем содержимым

**Детальное логирование очистки:**
- Количество удаленных элементов
- Подробный список с полными путями
- Причины удаления (аномальное окончание/группа с аномальными элементами)

### 4. Парсинг shop.blkx (shop_parser.py)
#### Сбор master-slave пар
**Выполняется ПОСЛЕ очистки данных:**
- Поиск элементов с полем `slaveUnit`
- Создание словаря пар `master_id -> slave_id`
- Формирование списка slave-юнитов для пропуска

#### Определение премиумных колонок
**Критерии премиумности:**
- Процент премиумной техники ≥ 30% (настраивается в `Constants.PREMIUM_THRESHOLD`)
- **Признаки премиумной техники** (из `Constants.PREMIUM_INDICATORS`):
  - `showOnlyWhenBought`
  - `gift`
  - `marketplaceItemdefId`
  - `isClanVehicle`
  - `showOnlyWhenResearch`
  - `event`
  - `hideFeature`
  - `beginPurchaseDate`/`endPurchaseDate`
  - `hideByPlatform`

#### Обработка зависимостей (предшественников)
**Правила определения предшественников:**

**Для обычной техники:**
- Если `reqAir` отсутствует или `reqAir != ""` → есть зависимость
- Если `reqAir = ""` → нет предшественника
- **Логика:**
  - Обычная техника зависит от предыдущего элемента
  - Первый элемент группы зависит от самой группы
  - Остальные элементы группы зависят от предыдущего элемента в группе
  - Техника после группы зависит от группы

**Для премиумной техники:**
- **Все предшественники = пустая строка** (независимо от `reqAir`)

#### Обработка групп
**Определение группы:**
- Название заканчивается на `_group` ИЛИ
- Содержит поле `image` ИЛИ
- Содержит вложенные элементы (не служебные поля из `Constants.SERVICE_FIELDS`)

**Обработка координат групп:**
- **Обычная техника:** координаты из `rankPosXY` или вычисляются
- **Премиумная техника:** элементы группы наследуют координаты группы

#### Обработка координат

**Обычная техника:**
```
column_index = номер столбца в JSON
row_index = rank - 1 (или из rankPosXY)
```

**Премиумная техника:**
```
column_index = 0, 1, 2... (счетчик премиум колонок)
row_index = группировка по рангам, внутри ранга: 0, 1, 2...
```

**Группировка премиум техники по рангам:**
- Ранг 1: row_index 0, 1, 2...
- Ранг 2: row_index 0, 1, 2...
- Ранг 3: row_index 0, 1, 2...

#### Master-slave обработка
- **Master-юниты** (например, `germ_iris_slm_fcs`) обрабатываются как обычная техника
- **Slave-юниты** (например, `germ_iris_slm_launcher`) пропускаются
- **Настройка:** `Constants.PROCESS_SLAVE_UNITS = False` (для будущего развития)

### 5. Парсинг локализации (localization_parser.py)

#### Загрузка и парсинг CSV локализации
**Приоритетная система обработки:**
- **Приоритет 1 (высший):** Записи с суффиксом `_shop` и `shop/group/`
- **Приоритет 10 (низкий):** Записи с числовыми суффиксами (`_0`, `_1`, `_2`)

**Алгоритм приоритетов:**
- При конфликте ключей выбирается запись с наивысшим приоритетом
- `ussr_zsu_37_2_shop` → ключ `ussr_zsu_37_2`, приоритет 1
- `ussr_zsu_37_2` → ключ `ussr_zsu_37_2`, приоритет 10
- Сохраняется значение из `_shop` записи

#### Типы обрабатываемых записей
1. **Записи с `_shop` суффиксом:**
   - `unit_name_shop` → ключ `unit_name`
   - Основная локализация для магазина

2. **Групповые записи:**
   - `shop/group/group_name` → ключ `group_name`
   - Локализация для папок/групп техники

3. **Записи с числовыми суффиксами:**
   - `unit_name_0`, `unit_name_1`, etc. → ключ `unit_name_0`, `unit_name_1`
   - Дополнительные варианты локализации

#### Стратегии поиска локализации
**Для каждого ID из shop.csv выполняется поиск в следующем порядке:**

1. **Прямой поиск точного совпадения**
   - Ищет `unit_id` в словаре локализации

2. **Точные совпадения с приоритетными суффиксами**
   - `unit_id + '_shop'` (приоритет 1)
   - `unit_id + '_1'` (приоритет 2)

3. **Поиск точных совпадений с любыми числовыми суффиксами**
   - Ищет ключи вида `unit_id + '_' + цифра`
   - Сортировка по приоритету: `_shop` → `_0` → `_1` → `_2`...

4. **Специальная обработка групп**
   - Для ID заканчивающихся на `_group`
   - Поиск ключей типа `shop/group/unit_id`

5. **Fallback**
   - Если ничего не найдено, возвращает сам ID

#### Примеры обработки локализации

**Обычный юнит:**
- shop.csv: `us_m41_walker_bulldog`
- Локализация: `us_m41_walker_bulldog_shop` → "M41A1"
- Результат: `us_m41_walker_bulldog` → "M41A1"

**Юнит с числом в названии:**
- shop.csv: `ussr_zsu_37_2`
- Локализация: `ussr_zsu_37_2_shop` → "ЗСУ-37-2"
- Конфликт: `ussr_zsu_37_2` → "ЗСУ" (приоритет 10)
- Результат: `ussr_zsu_37_2` → "ЗСУ-37-2" (выбран приоритет 1)

**Группа:**
- shop.csv: `he_112_group`
- Локализация: `shop/group/he_112_group` → "He 112"
- Результат: `he_112_group` → "He 112"

## Выходные данные

### Формат shop.csv
```csv
id,rank,country,vehicle_type,type,status,column_index,row_index,predecessor,order_in_folder
germ_pzkpfw_35t,1,germany,Наземная техника,vehicle,standard,0,0,,
germ_pzkpfw_38t_group,1,germany,Наземная техника,folder,standard,0,0,germ_pzkpfw_35t,
germ_pzkpfw_38t_ausf_F,1,germany,Наземная техника,vehicle,standard,0,0,germ_pzkpfw_38t_group,0
```

### Формат localization.csv
```csv
id,localized_name
us_m41_walker_bulldog,M41A1
ussr_zsu_37_2,ЗСУ-37-2
he_112_group,He 112
cn_t_62,Т-62 №545
```

### Описание полей shop.csv (из Constants.CSV_FIELDNAMES):
- **id:** Уникальный идентификатор техники
- **rank:** Ранг техники (1-8)
- **country:** Страна (germany, usa, ussr, etc.)
- **vehicle_type:** Тип техники (Наземная техника, Авиация, etc.)
- **type:** vehicle или folder
- **status:** standard или premium
- **column_index:** Номер колонки (для премиум техники: 0, 1, 2...)
- **row_index:** Позиция в колонке
- **predecessor:** ID предшественника (пусто для премиум техники)
- **order_in_folder:** Порядок в группе (0, 1, 2... или пусто)

### Описание полей localization.csv (из Constants.LOCALIZATION_CSV_FIELDNAMES):
- **id:** Уникальный идентификатор техники (совпадает с shop.csv)
- **localized_name:** Русское название техники

## Конфигурация

### config.txt
```
shop_url=https://example.com/shop.blkx
localization_url=https://raw.githubusercontent.com/example/repo/main/localization.csv
```

### Настройки в Constants
- `PREMIUM_THRESHOLD = 0.3` - порог определения премиум колонки (30%)
- `PROCESS_SLAVE_UNITS = False` - обрабатывать ли slave-юниты
- `ANOMALOUS_SUFFIXES = ['_race', '_football', '_yt_cup_2019', '_event']` - аномальные окончания

## Логирование

### Конфигурация логирования (Logger класс)
- **shop_parser_debug.log** - полная отладочная информация парсера shop.blkx (DEBUG уровень)
- **localization_parser_debug.log** - полная отладочная информация парсера локализации (DEBUG уровень)
- **Консоль** - основные этапы работы (INFO уровень)

### Уровни логирования
- **INFO:** Основные этапы (очистка, загрузка, обработка стран, сохранение)
- **DEBUG:** Детальная информация о каждом элементе, очистке и поиске локализации
- **WARNING:** Проблемы с данными
- **ERROR:** Критические ошибки

### Примеры логов очистки
```
Начинаем очистку от аномальных элементов...
  Очистка страны: germany
    УДАЛЕН: panzer_race (аномальное окончание)
    УДАЛЕНА ГРУППА: he_111_group (содержит аномальные элементы)
      Найден аномальный элемент в группе: he_111_football
Очистка завершена. Удалено элементов: 2
Подробный список удаленных элементов:
  - germany/Наземная техника/column_0/panzer_race
  - germany/Авиация/column_1/he_111_group (группа с аномальными элементами)
```

## Статистика выполнения

### По shop.blkx парсеру:
- Количество удаленных аномальных элементов
- Общее количество обработанных элементов
- Количество стандартной и премиумной техники
- Количество найденных master-slave пар
- Количество пропущенных slave-юнитов

### По парсеру локализации:
- Количество обработанных строк из CSV
- Количество найденных локализаций
- Количество fallback (не найденных) записей
- Статистика по приоритетам

## Обработка ошибок

### На уровне main.py:
- Проверка существования конфигурационного файла
- Обработка прерывания пользователем (Ctrl+C)
- Вывод пользовательских сообщений об ошибках
- Graceful обработка ошибок локализации (продолжение работы без неё)

### На уровне компонентов:
- **Config:** валидация конфигурационного файла
- **ShopParser:** проверка структуры данных, graceful handling сетевых ошибок, защита от аномальных элементов
- **LocalizationParser:** обработка некорректных CSV строк, приоритетное разрешение конфликтов
- **Logger:** логирование предупреждений для некорректных элементов

## Требования к окружению

- **Python 3.7+**
- **Стандартные библиотеки:** json, csv, logging, typing, sys, os
- **Внешние библиотеки:** requests
- **Файлы:** 
  - config.txt с корректным shop_url и localization_url
  - shop.csv (для работы только парсера локализации)

## Использование

### Полный парсинг (shop + локализация)
```bash
python main.py
python main.py --config my_config.txt
```

### Только парсинг shop.blkx
```bash
python main.py --shop-only
python main.py --config my_config.txt --shop-only
```

### Только парсинг локализации
```bash
python main.py --localization-only
python main.py --config my_config.txt --localization-only
```

### Справка
```bash
python main.py --help
```

### Результат выполнения:
- **shop.csv** - основные данные техники (очищенные от аномальных элементов)
- **localization.csv** - маппинг ID → русские названия
- **shop_parser_debug.log** - подробный лог парсера shop.blkx с информацией об очистке
- **localization_parser_debug.log** - подробный лог парсера локализации
- Статистика в консоли включая информацию об удаленных элементах

## Расширяемость архитектуры

### Добавление новых типов аномальных элементов:
1. Добавить новые окончания в `Constants.ANOMALOUS_SUFFIXES`
2. При необходимости расширить логику в `has_anomalous_suffix()`

### Добавление новых форматов экспорта:
1. Создать новый метод в `ShopParser` или `LocalizationParser` (например, `save_to_json()`)
2. Добавить константы в `Constants` при необходимости

### Добавление новых источников данных:
1. Расширить методы `fetch_shop_data()` или `fetch_localization_data()`
2. Добавить новые URL в конфигурацию

### Добавление новых языков локализации:
1. Изменить индекс колонки в `parse_localization_csv()`
2. Добавить параметр языка в конфигурацию

### Добавление новых типов логирования:
1. Расширить класс `Logger` в `utils.py`
2. Добавить новые обработчики логов

### Интеграция с базами данных:
1. Создать новый модуль `database_manager.py`
2. Объединить данные из shop.csv и localization.csv
3. Добавить методы для работы с различными СУБД

### Улучшение системы очистки:
1. Добавить новые типы проверок в `clean_anomalous_elements()`
2. Создать конфигурируемые правила очистки
3. Добавить whitelist для исключений

Модульная архитектура с интегрированной системой очистки обеспечивает стабильную работу с любыми входными данными, легкую поддержку и развитие проекта без нарушения существующей функциональности. Система приоритетов в парсере локализации гарантирует корректную обработку сложных случаев с конфликтующими записями, а предварительная очистка защищает от проблемных элементов.